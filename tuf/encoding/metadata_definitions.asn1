/*
This file defines the ASN.1 format for TUF metadata in a language-neutral,
platform-neutral manner.

This is not the *internal* format used in this TUF implementation, but it is
supported. Please see the TUF specification for the JSON format and more
detailed explanation of TUF metadata.

The TUF implementation in this repository uses modules in tuf.encoding and
the Python library asn1crypto to construct, convert, encode, and decode metadata
using ASN.1 and ASN.1/DER.

This file is likely to be of use for those trying to ensure compatibility with
the reference implementation but not using Python or using a different ASN.1
implementation.

The reference implementation uses module asn1_metadata_definitions.py to define
the Python- and asn1crypto-compatible form of these metadata definitions.

As a result, this file and asn1_metadata_definitions.py MUST remain consistent
with each other!


This file is organized into five sections:
   Common Definitions
   Root Role Definitions
   Timestamp Role Definitions
   Snapshot Role Definitions
   Targets Role Definitions


A note for implementers of TUF-specification-conformant systems:
There are constraints and optimizations that you can bake into your ASN.1
definitions. They are not included here for readability and simplicity.

Here are some example constraints and optimizations:
  Length Constraints
 Filename        ::= VisibleString (SIZE(1..256))

  Character Type constraint example: disallow '/' and '\'.
 StrictFilename  ::= VisibleString (SIZE(1..32))] (PATTERN "[^/\\]+")
 URLs            ::= SEQUENCE (SIZE(0..256)) OF URL
 URL             ::= VisibleString (SIZE(1..1024))

  Enumerations (optimization)
    You could swap in enums in place of some of the values that currently
    use strings. For example:
  RoleType        ::= ENUMERATED {root, targets, snapshot, timestamp}
  HashFunction ::= ENUMERATED {sha224, sha256, sha384, sha512, sha512-224,
                               sha512-256, ...}
  SignatureMethod ::= ENUMERATED {rsassa-pss, ed25519, ...}


A note for any future TUF/upTUF/Uptane repository maintainers:
 I'm excluding character type constraints at this stage. These constraints
 were always excluded in the  final .py module in any case (presumably due
 to compilation issues), so the only change is the removal of
 StrictFilename, which was functionally equivalent to Filename in any event.
 I'm also removing length constraints and enumerations to keep this simple
 for now. Implementers will impose their own length constraints in their
 ASN.1 definitions (or, if they are able, at a higher level) and perform
 their own optimizations.

A note on ordered/unordered translations of dictionaries:
 Note that the natural translation of a Python dictionary (which has no implicit
 order of elements) into ASN.1 is to a Set (unordered) of objects, and not a
 Sequence (ordered). For example, you can think of {'key_a': ..., 'key_b': ...}
 as (key_a_obj, key_b_obj), where the order is irrelevant.
 Despite this natural interpretation, there are some cases where we impose an
 order here in the translation to ASN.1. We do this when the dictionary is
 essentially a translation of an object/struct that contains disparate
 conceptual types. For example: {'keyid': ..., 'sig': ...} is translated as
 [keyid_object, sig_object], not (keyid_object, sig_object). This is to make the
 structure of objects in the wire format predictable. RootMetadata below is a
 good example: in the ASN.1/DER wire format, root metadata will always begin
 with a 'type' element, followed by 'expires', then 'version', etc.

 Already-ordered components like lists are, of course, always retained as
 ordered lists (Sequence). (e.g. the 'signatures' element of metadata is always
 ordered in both ASN.1 and the JSON-compatible metadata format.)


Questions:
 - Would it be better to use fewer empty wrapped classes? e.g. is it better to
   keep KeyID or just stick OCTET STRING into any keyid field?
   Consider simplicity, readability, extensibility.

 - Example enum candidates: KeyType, role in TopLevelDelegation

 - Should we add a top-level constrained rolename field? RoleType. Possible
   enum candidate, too.

 - In Target, custom and num-custom are both optional, but they should either
   both be here or both not be here. I could use a CustomSection object that's
   optional but when provided always contains both, but the additional level
   of abstraction doesn't match the internal TUF metadata format, and the cost
   of deviating on that point is probably higher than the cost of this
   ambiguity. EDIT: This is moot, as num- fields have been removed.

 - TopLevelDelegation may be a confusing name, since we usually refer to
   targets-level delegations when we talk about delegations; however, note that
   the info in TopLevelDelegation is information about root's delegation to the
   roles, not just role info. keys, threshold, etc. are pieces of a delegation,
   and this specific confusion around roles vs delegations has been very
   damaging in the past. (See TUF Issue #660)

 - I've tried to minimize the differences between this ASN.1 definition set and
   the TUF spec (which uses JSON). Consider each:
    - No dictionary structures (not clear it's possible?); instead, former
      dictionary elements are sequences, each with its former key being its
      first element. Names are provided; they're not just called "key"s.
    - Anywhere there was a list, a list length had to be added (e.g. roles is
      preceded by num-roles). EDIT: Removed this for now.
    - All underscores were necessarily removed, and replaced with dashes.

 - Timestamp and Snapshot in the TUF spec have dictionaries unhelpfully named
   'meta'. I've left that name here as well, but it's an awful name....
   It should be 'role-infos' or something along those lines.

 - The custom target fields are optional, but if the list appears, the length
   of that list should be required, ideally (custom needs num-custom). I can
   capture these in a single object,
   e.g. CustomSection optional: num-custom, customs
   It's a little longer and possibly less readable.
   EDIT: This concern is mooted by the removal of num- elements.

*/

TUFMetadataDefinitions DEFINITIONS AUTOMATIC TAGS ::= BEGIN



---------- Common ASN.1 definitions used by the various metadata types.

  IntegerNatural    ::= INTEGER (0..MAX)

  Hash ::= SEQUENCE {
    function            VisibleString,
    digest              OCTET STRING
  }

  Hashes ::= SET OF Hash


  Signature ::= SEQUENCE {
    keyid               OCTET STRING,
    method              VisibleString,
    value               OCTET STRING      -- the signature itself
  }

  PublicKey ::= SEQUENCE {
    keytype             VisibleString,
    scheme              VisibleString,
    keyval              SEQUENCE OF SEQUENCE {  -- even though we only expect 1
      type              VisibleString,          -- expect 'public'
      -- value here would ideally be an OCTET STRING, but for now, for
      -- compatibility with both ed25519 (hexstring that translates naturally to
      -- an OCTET STRING) and RSA (ASCII-prefixed Base64 that requires some
      -- translation), we'll just use an inefficient unicode string....
      value             VisibleString
    },
    keyid-hash-algorithms SEQUENCE OF VisibleString
  }
  -- A more streamlined definition of PublicKey would probably look like:
  --  {  keyid             OCTET STRING,
  --     public-key-value  OCTET STRING
  --  }



    -- This is a slghtly odd construction, but it models exactly what is used
    -- in the standard, JSON-compatible TUF metadata format.


---------- Root Role Metadata Definitions

  TopLevelDelegation ::= SEQUENCE {
    role                VisibleString,     -- ("root" | "timestamp" | "snapshot" | "targets"),
    keyids              SEQUENCE OF OCTET STRING,               -- ordered list
    threshold           IntegerNatural
    -- Pending TAP 5 approval and implementation:
    -- urls                SEQUENCE OF VisibleString OPTIONAL
  }

  RootMetadata ::= SEQUENCE {
    type                VisibleString,     -- ("root"),
    expires             IntegerNatural, --date&time, UTC, as a UNIX timestamp
    version             IntegerNatural,
    consistent-snapshot BOOLEAN,
    keys                SET OF PublicKey,                      -- unordered set
    roles               SET OF TopLevelDelegation}              -- unordered set
--  }






---------- Timestamp Role Metadata Definitions

  TimestampMetadata ::= SEQUENCE {
    type                VisibleString,     -- ("timestamp"),
    expires             IntegerNatural,  -- date&time, UTC, as a UNIX timestamp
    version             IntegerNatural,

    meta                SET OF RoleInfoLong                    -- unordered set
    -- What these should probably be called instead:
    -- role-infos       SET OF RoleInfoLong
  }

  RoleInfoLong ::= SEQUENCE {
    filename            VisibleString,    -- filename of snapshot metadata role
    version             IntegerNatural,
    hashes              SET OF Hash                            -- unordered set
  }





---------- Snapshot Role Metadata Definitions

  SnapshotMetadata ::= SEQUENCE {
    type                VisibleString,     -- ("snapshot"),
    expires             IntegerNatural,  -- date&time, UTC, as a UNIX timestamp
    version             IntegerNatural,

    meta                SET OF RoleInfo                 -- unordered set
    -- What these should probably be called instead:
    -- role-infos          SET OF RoleInfo
  }

  RoleInfo ::= SEQUENCE {
    filename            VisibleString,
    version             IntegerNatural
    -- Older versions of TUF used a hash here instead of a version number.
    -- Some intermediate versions used a hash for root and version numbers for
    -- targets role files. Root is no longer listed by snapshot, and we will
    -- always use version numbers now.
  }





---------- Targets Role Metadata Definitions
-- Covers both the top-level Targets role and delegated targets roles.

  TargetsMetadata ::= SEQUENCE {
    type                VisibleString,       -- allow delegated role names, too
    expires             IntegerNatural,  -- date&time, UTC, as a UNIX timestamp
    version             IntegerNatural,

    targets             SET OF Target,                -- unordered set

    delegations         SEQUENCE {
      -- "delegations" is a section containing two elements:
      --   keys: a list of public key information for use in delegations
      --   roles: a list of delegations
      --
      -- A delegation is an assignment, to another role, of the right to
      -- provide trustworthy fileinfo for targets (like the fileinfo above in
      -- Targets). A delegation specifies the role name, filename, public keys,
      -- and threshold of a delegatee.

      -- The full public keys available to use in delegations below, to be
      -- referenced below via key ID.
      keys                  SET OF PublicKey,         -- unordered set

      -- Each "role" listing below denotes one delegation. A delegation
      -- includes the role name, role filename, public keys, and key threshold
      -- of a delegatee.
      roles                 SEQUENCE OF Delegation    -- ordered list
    }
  }


  -- Metadata (fileinfo) about target files / images on a repository, used to
  -- validate them, including hashes and lengths, and sometimes custom
  -- metadata.
  Target ::= SEQUENCE {
    target-name         VisibleString,
    length              IntegerNatural,
    hashes              SET OF Hash,                          -- unordered list
    custom              SET OF Custom OPTIONAL -- Custom metadata elements
   }

  Custom ::= SEQUENCE {
    -- Each Custom object is a key-value pair. These specify custom attributes,
    -- additional fileinfo information. You could use this to provide the
    -- expected hash of an encrypted image, for example, or information about
    -- the clients for which this image is intended.
    key                 VisibleString,
    value               VisibleString
  }


  Delegation ::= SEQUENCE {

    -- A delegation is fundamentally a mapping from a portion of the Targets
    -- namespace to a set of signing constraints. In particular, it maps a
    -- glob pattern of filenames (for example, if you are using filenames) to
    -- a rolename, list of keys, and threshold of keys to expect for a role
    -- that is allowed to specify target file info for the targets matching the
    -- glob pattern. For more, see the TUF specification.

    name                VisibleString,
    keyids              SEQUENCE OF OCTET STRING,         -- ordered list
    paths               SEQUENCE OF VisibleString,        -- ordered list
    threshold           IntegerNatural,
    -- Whether or not this delegation is terminating.
    terminating         BOOLEAN DEFAULT FALSE
  }


  END
